# выболнить большую часть заданий ниже:

"""
======================================================================
1. Система типов: приведение к типам,
конкретные и абстрактные типы,
множественная диспетчеризация
"""

"""
что происходит с типами, какого типа `c` и почему?
"""
a = 1
b = 2.0
c = a + b
# переменные a и b имеют разные типы данных: a имеет целочисленный тип (Int), а b имеет тип с плавающей запятой (Float64). \
# При выполнении операции сложения переменных a и b переменная c автоматически приводится к типу Float64,
# потому что Julia использует приведение типов в порядке от менее точного к более точному.

"""
написать тип, параметризованный другим типом

"""

"""
написать функцию для двух аругментов, не указывая их тип,
и вторую функцию от двух аргментов с конкретными типами,
дать пример запуска
"""
function sum_values(x, y)
    return x + y
end

function sum_values_typed(x::Int, y::Int)
    return x + y
end


# Вызов функции без указания типов аргументов
result1 = sum_values(2, 3)
println("Результат функции без указания типов аргументов: ", result1)


# Вызов функции с указанием типов Int
result2 = sum_values_typed(2, 3)
println("Результат функции с указанием типов: ", result2)


# Вызов функции с указанием типов Int
result2 = sum_values_typed(2.0, 3)
println("Результат функции с указанием типов: ", result2)


"""
абстрактный тип - ключевое слово?
примитивный тип - ключевое слово?
композитный тип - ключевое слово?
"""

"""
написать один абстрактный тип и два его подтипа (1 и 2)
написать функцию над абстрактным типом, и функцию над её подтипом-1
выполнить функции над объектами подтипов 1 и 2 и объяснить результат
(функция выводит произвольный текст в консоль)
"""


"""
======================================================================
2. Функции:
лямбды и обычные функции,
переменное количество аргументов,
именованные аргументы со значениями по умолчанию,
кортежи
"""

"""
пример обычной функции
"""
function composition(x, y)
    return x * y   
end
"""
пример лямбда-функции (аннонимной функции)
"""
func = x -> println(x + 1)

"""
пример функции с переменным количеством аргументов
"""
function sum_values(args...)
    total = 0
    for arg in args
        total += arg
    end
    return total
end

"""
пример функции с именованными аргументами
"""
function greet_worker(name; job="Engineer", age=20)
    println("Hello, $name! You are a $job and you are $age years old.")
end


"""
функции с переменным кол-вом именованных аргументов
"""

"""
передать кортеж в функцию, которая принимает на вход несколько аргументов
присвоить кортеж результату функции, которая возвращает несколько аргументов
использовать splatting - деструктуризацию кортежа в набор аргументов
"""
# Определяем функцию, которая возвращает несколько аргументов
function division(x, y)
    return x ÷ y, x % y
end

# Присваиваем результат функции кортежу, используя splatting
chastnoe, ostatok = division(10, 3)

println("Частное: ", chastnoe)
println("Остаток: ", ostatok)

"""
======================================================================
3. loop fusion, broadcast, filter, map, reduce
"""

"""
перемножить все элементы массива
с помощью reduce
"""

arr = [2, 3, 4, 5]

result = reduce(*, arr)

println("Результат перемножения всех элементов массива: ", result)

"""
написать функцию от одного аргумента и запустить ее по всем элементам массива
с помощью точки (broadcast)
c помощью map
указать, чем это лучше явного цикла?
"""
# Определяем функцию, которая принимает один аргумент
function square(x)
    return x^2
end

# Создаем массив из чисел
arr = [2, 3, 4, 5]

# Рассчитываем результат при помощи точки и функции map()
result_broadcast = square.(arr)
result_map = map(square, arr)

# Оператор точки и функция map позволяют более компактно и эффективно писать код по сравнению
# с явным циклом
"""
перемножить вектор-строку [1 2 3] на вектор-столбец [10,20,30] и объяснить результат
"""
vector_row = [1 2 3]
vector_column = [10, 20, 30]
# Перемножение при помощи *:
result = vector_row * vector_column

# Результатом перемножения строки (Матрицы 1*3) и столбца (матрица 3*1) является матрица (1*1)

"""
в одну строку выбрать из массива [1, -2, 2, 3, 4, -5, 0] только четные и положительные числа
"""
arr = [1, -2, 2, 3, 4, -5, 0]
result = filter(x -> x > 0 && x % 2 == 0, arr)

"""
======================================================================
4. Свой тип данных на общих интерфейсах
"""

"""
написать свой тип ленивого массива, каждый элемент которого
вычисляется при взятии индекса (getindex) по формуле (index - 1)^2
"""

"""
Написать два типа объектов команд, унаследованных от AbstractCommand,
которые применяются к массиву:
`SortCmd()` - сортирует исходный массив
`ChangeAtCmd(i, val)` - меняет элемент на позиции i на значение val
Каждая команда имеет конструктор и реализацию метода apply!
"""
abstract type AbstractCommand end
apply!(cmd::AbstractCommand, target::Vector) = error("Not implemented for type $(typeof(cmd))")


"""
Аналогичные команды, но без наследования и в виде замыканий (лямбда-функций)
"""

"""
======================================================================
5. Тесты: как проверять функции?
"""

"""
написать тест для функции
"""

"""
======================================================================
6. Дебаг: как отладить функцию по шагам?
"""

"""
написать и отладить функцию по шагам с помощью макроса @enter и точек останова
"""

"""
======================================================================
7. Профилировщик: как оценить производительность функции?

"""

"""
оценить производительность функции с помощью макроса @profview
"""
function generate_data(len)
    vec1 = Any[]
    for k = 1:len
        r = randn(1,1)
        append!(vec1, r)
    end
    vec2 = sort(vec1)
    vec3 = vec2 .^ 3 .- (sum(vec2) / len)
    return vec3
end

@time generate_data(1_000_000);

"""
предложить, как переписать функцию так, чтобы она выполнялась быстрее?
"""

"""
======================================================================
8. Отличия от матлаба: приращение массива и предварительная аллокация?
"""

"""
написать функцию определения первой разности, которая принимает и возвращает массив
и для каждой точки входного (x) и выходного (y) выходного массива вычисляет:
y[i] = x[i] - x[i-1]
"""
function first_differences(x)
    y = []
    for i in 2:length(x)
        push!(y, x[i] - x[i-1])
    end

    return y
end

# Пример использования функции
input_array = [1, 3, 6, 10, 15]
output_array = first_differences(input_array)


"""
аналогичная функция, которая отличается тем, что внутри себя не аллоцирует новый массив y,
а принимает его первым аргументом, сам массив аллоцируется до вызова функции
"""
function first_differences!(x, y)
    for i in 2:length(x)
        y[i-1] = x[i] - x[i-1]
    end
    return y
end

# Пример использования функции
input_array = [1, 3, 6, 10, 15]
output_array = zeros(Int, length(input_array) - 1)  # Создаем массив для хранения результатов
first_differences!(input_array, output_array)



"""
написать код, который добавляет элементы в конец массива, в начало массива,
в середину массива
"""

"""
======================================================================
9. Модули и функции: как оборачивать функции внутрь модуля, как их экспортировать
и пользоваться вне модуля?
"""


"""
написать модуль с двумя функциями,
экспортировать одну из них,
воспользоваться обеими функциями вне модуля
"""
module Foo
    #export ?
end
# using .Foo ?
# import .Foo ?

"""
======================================================================
10. Зависимости, окружение и пакеты
"""

"""
что такое environment, как задать его, как его поменять во время работы?
"""

"""
что такое пакет (package), как добавить новый пакет?
"""
# Пакет (package) - это набор компонентов (библиотек, модулей, функций)
# с определенным назначением или функциональностью, который можно использовать в коде.
# Для добавления нового пакета используется встроенный менеджер пакетов Pkg. 
# Для установки пакета необходимо использовать команду `using Pkg; Pkg.add("Package_Name")`, 
# где "Package_Name" - название пакета, который нужно установить.

"""
как начать разрабатывать чужой пакет?
"""

"""
как создать свой пакет? (сложный вопрос, поэтому необязательно)
"""

"""
======================================================================
11. Аргументы запуска Julia
"""

"""
Как задать окружение при запуске?
"""

"""
Как задать скрипт, который будет выполняться при запуске:
а) из файла .jl
б) из текста команды? (см. флаг -e)
"""
